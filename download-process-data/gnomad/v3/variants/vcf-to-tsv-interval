#!/usr/bin/env python

from cyvcf2 import VCF
import argparse
import pandas as pd

from colorize import print_string_as_info

def discard(variant):   
  # https://brentp.github.io/cyvcf2/docstrings.html#cyvcf2.cyvcf2.Variant.FILTER
  if variant.FILTER:
    print_string_as_info('variant is not PASS')
    return True

  # sanity check (gnomad v3)
  if variant.INFO.get('AC') == 0: 
    print(variant)
    raise ValueError('PASS variants should have non-zero allele count!')

  # sanity check (gnomad v3)
  if len(variant.ALT) != 1: 
    print(variant)
    raise ValueError(
      'Since multi-allelic variants appear as separate VCF records, '
      'there should be exactly one ALT allele per VCF record!'
    )

  return False

def fetch_vep_keys(filename):
  keys = [] 
  with open(filename, 'r') as fh: 
    for line in fh.readlines(): 
      keys.append(line.rstrip()) 
  return keys

def unpack_variants_in_interval(args):
  vep_keys = fetch_vep_keys(args.vep_keys)  
  vcf = VCF(args.vcf)      
  variants = []  
  for variant in vcf(args.interval):              
    if discard(variant): continue 

    # p8 of vcf spec says that 
    # when multiple values correspond to a single INFO key (here "vep"), 
    # those values must be separated by a comma: 
    # https://samtools.github.io/hts-specs/VCFv4.3.pdf
    for transcript_annotations in variant.INFO.get('vep').split(','):
      variant_relative_to_transcript = {}
  
      variant_relative_to_transcript['chromosome'] = variant.CHROM
      variant_relative_to_transcript['start'] = variant.start
      variant_relative_to_transcript['end'] = variant.end

      # Possible values are "snv", "indel", "multi-snv", "multi-indel", or "mixed" :
      variant_relative_to_transcript['variant_type'] = variant.INFO.get('variant_type') 

      variant_relative_to_transcript['REF'] = variant.REF
      variant_relative_to_transcript['ALT'] = variant.ALT[0]
      # Total number of alternate alleles observed at variant's locus : 
      variant_relative_to_transcript['number_ALT'] = variant.INFO.get('n_alt_alleles') 

      variant_relative_to_transcript['number_ALT_individuals'] = variant.INFO.get('AC')
      variant_relative_to_transcript['number_individuals'] = variant.INFO.get('AN')

      vep_values_for_transcript = transcript_annotations.split('|')
      for vep_key, vep_value in zip(vep_keys, vep_values_for_transcript): 
        if vep_key in {
          'SYMBOL', 
          'Gene', 
          'Consequence', 
          'Feature_type', 
          'Feature', 
          'Amino_acids',
          'CANONICAL'
        }: variant_relative_to_transcript[vep_key] = vep_value if vep_value else '.'
                      
      variants.append(variant_relative_to_transcript)

  vcf.close()
  
  return variants 

def parse_arguments():
    parser = argparse.ArgumentParser(description='')

    parser.add_argument('--interval', type=str, dest='interval')
    parser.add_argument('--vcf', type=str, dest='vcf', help='')
    parser.add_argument('--vep-keys', type=str, dest='vep_keys', help='')
    parser.add_argument('--tmpdir', type=str, dest='tmpdir', help='')

    return parser.parse_args()

def vcf_to_tsv_interval():
  args = parse_arguments()
  
  variants = unpack_variants_in_interval(args)

  if len(variants) > 0: 
    pd.DataFrame(variants).to_csv(
      f'{args.tmpdir}/{args.interval}.tsv', 
      index=False, 
      sep="\t", 
      # header=None
    )
    print(f'Converted variants within {args.interval} from vcf format to tab-delimited format.')
    print('Ready to merge...')
  else: 
    print(f'There are no variants within {args.interval} to convert from vcf to tab-delimited format!')
    
if __name__ == '__main__':
  vcf_to_tsv_interval()
