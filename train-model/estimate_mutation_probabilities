#!/usr/bin/env python

# pysam API: 
# https://github.com/pysam-developers/pysam/blob/b82cbcae22c088e64fdb58f8acaf1e9773c7b088/pysam/libctabix.pyx
import pysam

import numpy as np
import json
import argparse 
import gzip 
import concurrent.futures
import functools
import copy
import os

from kmer import check_for_Ns, initialize_kmer_data, fetch_kmer_from_sequence, alternate_bases, middle_base, get_bases, contains_unspecified_bases
from colorize import print_json, print_string_as_info, print_string_as_info_dim, print_unbuffered, print_string_as_error
import color_traceback 
from fetch_SNVs import fetch_SNVs 
from pack_unpack import unpack
from timer import timer 

#%%
def parse_arguments():
  parser = argparse.ArgumentParser(description='')
  parser.add_argument('--kmer-size', type=int, dest='kmer_size', help='')
  parser.add_argument('--genome', type=str, help='')
  parser.add_argument('--region', type=str, help='')
  parser.add_argument('--number-samples', type=int, dest='number_samples', help='')
  parser.add_argument('--model', type=str, help='')
  parser.add_argument('--mutations', type=str, help='')
  return parser.parse_args()
#%%

#%%
# using the "khmer" library might make this function a handful of times faster:
# https://khmer.readthedocs.io/en/v0.6.1-0/ktable.html
def compute_total_counts_region(genome, kmer_data, region, args): 
  # "fetch" API: https://pysam.readthedocs.io/en/latest/api.html?highlight=fasta#pysam.FastaFile
  # Note that fetch(region=region) does not work if the coordinates in "region" contains commas
  # Workaround is to parse "region" into "chromosome", "start", "end": 
  neutral_region = genome.fetch(*unpack(region))    
  print("Sequence for neutral region coordinates {} is {}".format(region, neutral_region))

  print_string_as_info('Iterating over neutral region {} and counting kmers:'.format(region))
  number_of_kmers_containing_unspecified_bases = 0
  for position in np.arange(0, len(neutral_region), 1):
    try: 
      kmer = fetch_kmer_from_sequence(neutral_region, position, args.kmer_size)
    except IndexError:
      print_string_as_info_dim('IndexError at position: {}'.format(position))
      continue
    if contains_unspecified_bases(kmer): 
      number_of_kmers_containing_unspecified_bases += 1 
      continue 
    kmer_data[kmer]['cohort_sequence_count'] += args.number_samples 
    kmer_data[kmer]['sequence_count'] += 1

  print_string_as_info_dim(
    f'Number of kmers containing unspecified bases: {number_of_kmers_containing_unspecified_bases}'
  )
  print_unbuffered('')

  return kmer_data
#%%

#%%
def compute_snv_counts_region(mutations, genome, kmer_data, region, args):
  print_string_as_info('Fetching SNVs in region {} and incrementing corresponding kmer counts\n'.format(region))

  SNVs = fetch_SNVs(mutations, genome, region, args.__dict__)
  if SNVs is not None: 
    if len(SNVs) > 0:
      for SNV in SNVs: 
         print(SNV)
         #print(SNV['ALT'], SNV['allele_count'])
         kmer_data[SNV['kmer']]['ALT_counts'][SNV['ALT']] += int(SNV['allele_count'])
         #print(kmer_data[SNV['kmer']])
      return kmer_data
#%%

#%%
def get_hostname_process_cpu(): 
  hostname = os.uname()[1]
  pid = os.getpid()
  cpu = subprocess.run(
    ["ps", "-o", "psr=", "-p", f"{pid}"], 
    capture_output=True
  ).stdout.decode("utf-8").strip()
  return {
    'hostname': hostname,
    'process': pid, 
    'cpu': f'{cpu}/{multiprocessing.cpu_count()}'
  }
#%%

#%%
# https://github.com/pysam-developers/pysam/issues/397#issuecomment-328451288
@timer 
def compute_counts_region(region, args):  
  print_json({'region': region, **get_hostname_process_cpu()})

  kmer_data = initialize_kmer_data(args) 

  # pysam.FastaFile uses the index produced by "samtools faidx": 
  # https://pysam.readthedocs.io/en/latest/api.html?highlight=fasta#pysam.FastaFile
  with pysam.TabixFile(args.mutations) as mutations, pysam.FastaFile(args.genome) as genome: 
    kmer_data = compute_total_counts_region(genome, kmer_data, region, args) 
    kmer_data = compute_snv_counts_region(mutations, genome, kmer_data, region, args)

  return kmer_data 
#%%

#%%
# https://realpython.com/primer-on-python-decorators/
def diagnostics(func):
  @functools.wraps(func)
  def wrapper(*args, **kwargs):
    print_unbuffered(f'diagnostics: function: {func.__name__}\n')
    regions, counts = func(*args, **kwargs)
    for region, count in zip(regions, counts): 
      kmer = 'AAAAA'
      print_unbuffered(f'\ndiagnostics: region: {region}') 
      print_unbuffered(f'diagnostics: counts for {kmer}:')
      print_json(count[kmer])
    return regions, counts
  return wrapper
#%%

#%%
def estimate_mutation_probabilities():
  ## Define arguments 
  args = parse_arguments()
  
  print("Estimating mutation probabilities for {}".format(args.region))

  ## Count kmers and mutations within the neutral region of interest
  kmer_data = compute_counts_region(args.region, args)

  ## Write the model to output
  model_path = args.model + '/' + args.region + '.model.json'
  with open(model_path, 'w') as fh:
    json.dump({
      'mutations': args.mutations,
      'genome': args.genome,
      'kmer_size': args.kmer_size,
      'neutral_region': args.region,
      'number_samples': args.number_samples,
      'kmer_data': kmer_data
    }, fh, indent=2)
  print_string_as_info('Writing multinomial model to disk at: {}'.format(model_path))
#%%  

if __name__ == '__main__':
  estimate_mutation_probabilities()  

